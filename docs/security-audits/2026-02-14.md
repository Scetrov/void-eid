# VoID eID — Security Audit Report

**Date:** 14 February 2026
**Auditor Role:** Senior Security Researcher / DevSecOps Engineer
**Scope:** Full-stack audit — Rust/Axum backend, React/Vite frontend, Docker infrastructure, CI/CD pipelines, Mumble integration
**Standards:** OWASP Top 10:2025, MITRE ATT&CK, NIST SP 800-53, CIS Benchmarks

---

## 1. Executive Summary

Overall Risk Rating: **MEDIUM**

The VoID eID codebase demonstrates several positive security practices — parameterized SQL queries throughout (no SQLx string interpolation), proper Sui wallet signature verification, tribe-scoped access control, comprehensive audit logging, and a `RequireSuperAdmin` middleware that re-validates against environment variables rather than trusting JWT claims. However, the audit identified several findings across authentication, infrastructure, and operational security domains that warrant remediation.

**Top 3 Critical Risks:**

1. **Missing OAuth2 `state` parameter** — The Discord OAuth2 login flow has no CSRF protection, allowing a session fixation attack where an attacker could bind a victim's browser session to the attacker's Discord identity.
2. **JWT token transmitted in URL query string** — After OAuth callback, the JWT bearer token is placed in a redirect URL, exposing it in browser history, Referer headers, and server logs.
3. **Hardcoded ICE/Internal secrets with weak defaults** — Murmur ICE secrets are hardcoded to `"secret"` in configuration and startup scripts, and the `INTERNAL_SECRET` environment variable defaults to `"secret"` or `"changeme"` when unset.

---

## 2. Detailed Findings

| ID     | Vulnerability Name                                                          | Severity   | Location                               | OWASP 2025              | MITRE ATT&CK |
| ------ | --------------------------------------------------------------------------- | ---------- | -------------------------------------- | ----------------------- | ------------ |
| SEC-01 | Missing OAuth2 `state` parameter (CSRF)                                     | **High**   | auth.rs                                | A07:2025                | T1078.004    |
| SEC-02 | JWT token in URL query string                                               | **High**   | auth.rs                                | A02:2025                | T1528        |
| SEC-03 | Hardcoded ICE secrets & weak defaults                                       | **High**   | murmur.ini, start.sh, authenticator.py | A02:2025                | T1552.001    |
| SEC-04 | `INTERNAL_SECRET` defaults to `"secret"`                                    | **High**   | auth.rs                                | A07:2025                | T1078        |
| SEC-05 | No rate limiting on authentication endpoints                                | **Medium** | main.rs                                | A07:2025                | T1110        |
| SEC-06 | Backend Docker containers run as root                                       | **Medium** | Dockerfile                             | A05:2025                | T1611        |
| SEC-07 | Database error details leaked to clients                                    | **Medium** | auth.rs, wallet.rs                     | A05:2025                | T1592        |
| SEC-08 | Wallet nonces have no TTL/expiration                                        | **Medium** | wallet.rs, state.rs                    | A07:2025                | T1550        |
| SEC-09 | No Content-Security-Policy headers                                          | **Medium** | nginx.conf                             | A05:2025                | T1059.007    |
| SEC-10 | No input length/size validation                                             | **Low**    | notes.rs, admin.rs                     | A03:2025                | T1499        |
| SEC-11 | GitHub Actions not SHA-pinned                                               | **Low**    | ci.yml                                 | A08:2025 (Supply Chain) | T1195.002    |
| SEC-12 | `is_super_admin` JWT claim not revalidated in `AuthenticatedUser` extractor | **Low**    | auth.rs                                | A01:2025                | T1078        |

---

### SEC-01: Missing OAuth2 `state` Parameter (CSRF)

**Description:** The `discord_login` endpoint at auth.rs constructs the Discord OAuth2 authorization URL without a `state` parameter. The `discord_callback` handler does not validate any `state` token.

**Impact:** An attacker can craft a link to Discord's OAuth2 authorization endpoint using the application's client_id. When a victim clicks it, the resulting callback code can be replayed to the application, potentially binding the victim's session to an attacker-controlled Discord account (session fixation), or the reverse — forcing a login to the attacker's account.

**Guidance/Fix:**

```rust
// In discord_login:
let state_token = Uuid::new_v4().to_string();
// Store state_token in a short-lived server-side store (or signed cookie)
state.oauth_states.lock().unwrap().insert(state_token.clone(), Utc::now());

let url = format!(
    "https://discord.com/api/oauth2/authorize?client_id={}&redirect_uri={}&response_type=code&scope={}&state={}",
    client_id, urlencoding::encode(&redirect_uri), scope, state_token
);

// In discord_callback:
// Validate params.state exists and matches a stored token, then remove it
```

---

### SEC-02: JWT Token in URL Query String

**Description:** At auth.rs, after successful Discord OAuth2 callback, the JWT is passed to the frontend via:

```rust
Redirect::to(&format!("{}/auth/callback?token={}", frontend_url, token))
```

**Impact:** The JWT appears in browser history, can leak via `Referer` headers if the callback page loads external resources, and can be logged by reverse proxies or WAFs. This is a credential exposure risk per NIST SP 800-63B §5.1.3.

**Guidance/Fix:** Use a short-lived, one-time authorization code pattern instead:

1. Store the JWT keyed by a random code in a server-side store (with 30s TTL).
2. Redirect with `?code=<random_code>` only.
3. Frontend calls `POST /api/auth/exchange` with the code to retrieve the JWT in a response body.

Alternatively, set the JWT as an `HttpOnly`, `Secure`, `SameSite=Strict` cookie in the redirect response instead of putting it in the URL.

---

### SEC-03: Hardcoded ICE Secrets & Weak Defaults

**Description:**

- murmur.ini: `icesecretread=secret` and `icesecretwrite=secret` are hardcoded.
- start.sh: `export ICE_SECRET="secret"` is hardcoded.
- authenticator.py: `internal_secret = os.environ.get("INTERNAL_SECRET", "changeme")`.
- authenticator.py: Falls back to `"secret"` for ICE if env var is empty.

**Impact:** Anyone with network access to the ICE port (6502) can authenticate and control the Murmur server — registering users, kicking users, changing server configuration. Although the port is bound to `127.0.0.1` in murmur.ini, it is exposed in the Docker container (port 6502 in Dockerfile).

**Guidance/Fix:**

- Generate strong random secrets at deployment time via `openssl rand -hex 32`.
- Template murmur.ini to inject `icesecretread` and `icesecretwrite` from environment variables in start.sh.
- Remove the hardcoded fallback of `"secret"` in start.sh and authenticator.py; fail loudly if the secret is not configured.
- Do NOT expose port 6502 in the Docker container or docker-compose.yml.

---

### SEC-04: `INTERNAL_SECRET` Defaults to `"secret"`

**Description:** At auth.rs:

```rust
let configured_secret = env::var("INTERNAL_SECRET").unwrap_or_else(|_| "secret".to_string());
```

If `INTERNAL_SECRET` is not set, the Mumble internal API (verify endpoint) will accept `X-Internal-Secret: secret`.

**Impact:** If deployed without explicit `INTERNAL_SECRET` configuration, any caller who guesses the default can invoke the internal Mumble verification API, potentially impersonating the authenticator.

**Guidance/Fix:** Fail with a panic or startup error if `INTERNAL_SECRET` is not set, similar to how `IDENTITY_HASH_PEPPER` is handled in state.rs:

```rust
let configured_secret = env::var("INTERNAL_SECRET")
    .expect("INTERNAL_SECRET must be set");
```

---

### SEC-05: No Rate Limiting on Authentication Endpoints

**Description:** No rate limiting middleware is applied to any endpoint, including `/api/auth/discord/login`, `/api/auth/discord/callback`, `/api/wallets/link-nonce`, `/api/wallets/link-verify`, and `/api/internal/mumble/verify`.

**Impact:** Enables brute-force attacks against the Mumble verify endpoint, nonce flooding against the wallet linking flow, and potential OAuth abuse.

**Guidance/Fix:** Add `tower::limit::RateLimitLayer` or use `tower_governor` crate:

```rust
use tower_governor::{GovernorLayer, GovernorConfigBuilder};

let governor_conf = GovernorConfigBuilder::default()
    .per_second(2)
    .burst_size(5)
    .finish()
    .unwrap();

// Apply to sensitive routes
.route("/api/auth/discord/callback", get(auth::discord_callback))
    .layer(GovernorLayer { config: governor_conf })
```

---

### SEC-06: Backend Docker Container Runs as Root

**Description:** The backend Dockerfile and frontend Dockerfile do not define a non-root user. Containers run as `root` by default.

**Impact:** If an attacker achieves remote code execution via the application, they have full root privileges within the container, facilitating container escape (CIS Docker Benchmark 4.1).

**Guidance/Fix:**

```dockerfile
# Backend Dockerfile - add before CMD:
RUN groupadd -r appuser && useradd -r -g appuser appuser
RUN mkdir -p /data && chown appuser:appuser /data
USER appuser

# Frontend Dockerfile - add before CMD:
RUN groupadd -r appuser && useradd -r -g appuser appuser
USER appuser
```

Note: Nginx requires port 80 changes if running as non-root. Use port 8080 and a non-privileged nginx configuration, or use a rootless nginx image.

---

### SEC-07: Database Error Details Leaked to Clients

**Description:** Several error handlers return raw database error messages to the client:

- auth.rs: `format!("DB Error: {}", e)`
- auth.rs: `format!("Discord token exchange failed: Status: {}, Body: {}", status, body)`
- wallet.rs: `format!("DB Error: {}", e)`

**Impact:** Information disclosure — SQLite error messages can reveal table names, column names, and query structure, aiding further attacks.

**Guidance/Fix:** Log the full error server-side with `tracing::error!()` and return a generic 500 error to clients:

```rust
.map_err(|e| {
    eprintln!("Database error: {}", e); // or tracing::error!
    (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error")
})?;
```

---

### SEC-08: Wallet Nonces Have No TTL/Expiration

**Description:** In wallet.rs and state.rs, the `wallet_nonces` HashMap stores nonces with no expiration. Nonces are only removed when consumed.

**Impact:** Unused nonces accumulate indefinitely (memory leak DoS potential). Additionally, a nonce generated but never consumed remains valid forever, widening the attack surface for replay if an attacker captures a nonce.

**Guidance/Fix:** Store nonces with a timestamp and add a TTL check:

```rust
pub wallet_nonces: Arc<Mutex<HashMap<String, (String, chrono::DateTime<chrono::Utc>)>>>,

// On retrieval, validate age:
let (nonce, created_at) = nonces.remove(&address_str)
    .ok_or((StatusCode::BAD_REQUEST, "Nonce invalid or expired".into()))?;
if Utc::now() - created_at > chrono::Duration::minutes(5) {
    return Err((StatusCode::BAD_REQUEST, "Nonce expired".into()));
}
```

---

### SEC-09: No Content-Security-Policy Headers

**Description:** The nginx.conf serves the SPA without any security headers (CSP, X-Frame-Options, X-Content-Type-Options, Strict-Transport-Security).

**Impact:** Increases susceptibility to XSS, clickjacking, and MIME-type sniffing attacks.

**Guidance/Fix:**

```nginx
server {
    listen 80 default_server;

    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; connect-src 'self' https://*.suiscan.xyz https://*.mysten.sui.io;" always;
    # Add HSTS when behind TLS termination:
    # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    location / { ... }
}
```

---

### SEC-10: No Input Length/Size Validation

**Description:** The `CreateNoteRequest`, `CreateTribeRequest`, and `AddUserToTribeRequest` payloads have no server-side length limits. For example, notes.rs only checks `content.trim().is_empty()` but allows arbitrarily large content.

**Impact:** An attacker could submit extremely large payloads, causing excessive database storage and potentially slowing queries (resource exhaustion / DoS).

**Guidance/Fix:**

```rust
if payload.content.len() > 10_000 {
    return (StatusCode::BAD_REQUEST, "Note content exceeds maximum length").into_response();
}
```

---

### SEC-11: GitHub Actions Not SHA-Pinned

**Description:** The CI/CD workflows use tag-based references for third-party actions (e.g., `actions/checkout@v6`, `oven-sh/setup-bun@v2`). One exception: `jlumbroso/free-disk-space` is correctly SHA-pinned in ci.yml.

**Impact:** If a third-party GitHub Action is compromised (tag overwrite), malicious code could execute in the CI runner, stealing secrets or injecting backdoors (supply chain attack per CISA guidance on CI/CD security).

**Guidance/Fix:** Pin all non-GitHub-official actions to commit SHAs:

```yaml
- uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v6
- uses: oven-sh/setup-bun@735343b667d3e6a283f1b0f4a75e9d9afc0d7777 # v2
```

Add a tool like Dependabot or Renovate to track SHA updates.

---

### SEC-12: `is_super_admin` JWT Claim Not Revalidated in `AuthenticatedUser`

**Description:** At auth.rs, the `AuthenticatedUser` extractor trusts the `is_super_admin` claim from the JWT without re-checking the environment variable. While the `RequireSuperAdmin` middleware correctly re-validates, the `is_super_admin` field on `AuthenticatedUser` is surfaced to the frontend via `get_me`.

**Impact:** If an admin is removed from `SUPER_ADMIN_DISCORD_IDS`, their existing JWT (valid up to 24h) will still show `isSuperAdmin: true` in the `/api/me` response. The frontend may display the admin panel link, though actual admin API calls will fail (protected by `RequireSuperAdmin`). This is a confusing UX inconsistency and minor information leak.

**Guidance/Fix:** Either shorten JWT expiration for super admins, re-check the env var in `get_me`, or remove `is_super_admin` from JWT claims entirely and always derive it from the environment variable:

```rust
// In get_me handler:
let super_admin_ids_str = std::env::var("SUPER_ADMIN_DISCORD_IDS").unwrap_or_default();
let super_admin_ids: Vec<&str> = super_admin_ids_str.split(',').map(|s| s.trim()).collect();
let is_super_admin = super_admin_ids.contains(&user.discord_id.as_str());
```

---

## 3. Infrastructure & CI/CD Review

### Docker Security

| Check                   | Status   | Notes                                                                                                                 |
| ----------------------- | -------- | --------------------------------------------------------------------------------------------------------------------- |
| Non-root container user | **FAIL** | Backend and frontend Dockerfiles run as root (SEC-06)                                                                 |
| Minimal base images     | **PASS** | Uses `debian:trixie-slim` — slim variant is appropriate                                                               |
| Multi-stage builds      | **PASS** | Frontend uses multi-stage build, backend copies a pre-built binary                                                    |
| No secrets in images    | **PASS** | Secrets are injected via env_file at runtime                                                                          |
| Read-only filesystem    | **FAIL** | No `read_only: true` in docker-compose; containers can write anywhere                                                 |
| Health checks           | **FAIL** | No `HEALTHCHECK` in any Dockerfile                                                                                    |
| ICE port exposure       | **WARN** | Port 6502 (ICE) is exposed in the Murmur Dockerfile but not in docker-compose — verify it's not exposed in production |

### CI/CD Pipeline

| Check              | Status      | Notes                                                                    |
| ------------------ | ----------- | ------------------------------------------------------------------------ |
| Permissions scoped | **PASS**    | `permissions: contents: read` set at workflow level in CI                |
| Secrets handling   | **PASS**    | Uses `${{ secrets.GITHUB_TOKEN }}` for registry auth; no secrets in logs |
| Action pinning     | **PARTIAL** | `jlumbroso/free-disk-space` is SHA-pinned; others are tag-based (SEC-11) |
| CodeQL scanning    | **PASS**    | Both JS/TS and Rust are scanned via CodeQL on schedule and PR            |
| Binary signing     | **FAIL**    | Release artifacts are not signed (no cosign/sigstore integration)        |
| SBOM generation    | **FAIL**    | No Software Bill of Materials generated for release artifacts            |

---

## 4. Compliance Check

### NIST SP 800-53 Mapping

| Control                                    | Assessment  | Notes                                                                                      |
| ------------------------------------------ | ----------- | ------------------------------------------------------------------------------------------ |
| **AC-2** (Account Management)              | **Partial** | Audit logs track login/admin actions; no automatic account expiration                      |
| **AC-3** (Access Enforcement)              | **Pass**    | Tribe-scoped RBAC via `require_admin_in_tribe()`; super admin gated by `RequireSuperAdmin` |
| **AC-7** (Unsuccessful Logon Attempts)     | **Fail**    | No lockout or rate limiting (SEC-05)                                                       |
| **AU-2** (Event Logging)                   | **Pass**    | Comprehensive audit logging with `AuditAction` enum                                        |
| **AU-3** (Content of Audit Records)        | **Pass**    | Logs include actor, target, action, details, timestamps                                    |
| **IA-2** (Identification & Authentication) | **Partial** | OAuth2 provides strong IdP-backed auth; missing CSRF protection (SEC-01)                   |
| **SC-8** (Transmission Confidentiality)    | **Partial** | HTTPS expected in production but JWT exposure via URL (SEC-02); no HSTS header             |
| **SC-13** (Cryptographic Protection)       | **Pass**    | JWT HS256 signing, bcrypt for Mumble passwords, Sui Ed25519 signature verification         |
| **SI-10** (Information Input Validation)   | **Partial** | Parameterized queries everywhere (no SQLi); missing input length validation (SEC-10)       |

### CIS Docker Benchmark v1.6

| Control                                         | Assessment               |
| ----------------------------------------------- | ------------------------ |
| **4.1** Run as non-root                         | **Fail** (SEC-06)        |
| **4.6** Add HEALTHCHECK                         | **Fail**                 |
| **4.9** Use COPY instead of ADD                 | **Pass**                 |
| **4.10** Don't store secrets in Dockerfiles     | **Pass**                 |
| **5.2** Verify SELinux/AppArmor profiles        | **N/A** (not configured) |
| **5.12** Mount container's root FS as read-only | **Fail**                 |

---

## 5. Positive Findings

These security practices are commendable and should be maintained:

1. **All SQL queries are parameterized** — No string interpolation in any SQLx query across the entire codebase.
2. **Tribe isolation is enforced at query level** — `require_admin_in_tribe()` consistently gates admin operations.
3. **`RequireSuperAdmin` re-validates against env var** — Does not trust JWT claims for super admin authorization.
4. **Comprehensive audit logging** — All state-changing operations are logged with actor/target/details.
5. **Sui wallet signature verification uses cryptographic SDK** — `verify_secure()` from the official Sui SDK.
6. **CORS is scoped to specific origins** — Not using wildcard `*`.
7. **Account deletion properly anonymizes and denylists** — GDPR-compliant deletion with identity hashing to prevent re-registration.
8. **Soft-delete for wallets** — Preserves audit trail while respecting deletion.

---

## 6. Prioritized Remediation Roadmap

| Priority             | Finding                                  | Effort  |
| -------------------- | ---------------------------------------- | ------- |
| **P0 — Immediate**   | SEC-01: Add OAuth2 `state` parameter     | Small   |
| **P0 — Immediate**   | SEC-04: Remove `INTERNAL_SECRET` default | Trivial |
| **P0 — Immediate**   | SEC-03: Externalize Murmur ICE secrets   | Small   |
| **P1 — Short-term**  | SEC-02: Remove JWT from URL redirect     | Medium  |
| **P1 — Short-term**  | SEC-06: Run containers as non-root       | Small   |
| **P1 — Short-term**  | SEC-05: Add rate limiting                | Medium  |
| **P2 — Medium-term** | SEC-07: Sanitize error responses         | Small   |
| **P2 — Medium-term** | SEC-09: Add security headers             | Small   |
| **P2 — Medium-term** | SEC-08: Add nonce TTL                    | Small   |
| **P3 — Long-term**   | SEC-11: SHA-pin all GitHub Actions       | Small   |
| **P3 — Long-term**   | SEC-10: Add input length validation      | Small   |
| **P3 — Long-term**   | SEC-12: Remove `is_super_admin` from JWT | Small   |

Completed: _Compile security audit report_ (6/6)
